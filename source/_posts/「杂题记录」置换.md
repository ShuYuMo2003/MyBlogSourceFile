---
title: 「正睿OI」「国庆集训-重庆」置换
mathjax: true
date: 2020-11-18 11:42:50
tags:
 - 题解
 - 正睿
categories:
 - 杂题记录
---

{% note info %}
对于长度为 $n$ 的置换 $A,B$ ，求是否存在正整数 $k$ 使得 $A^k=B$

定义置换的乘法为 
$C = (A \cdot B), C_i=A_{B_i}$

定义 $A^1=A,A^n=A^{n-1} \cdot A(n > 1)$

如果存在 `k` 输出 `Yes` 否则输出 `No` 。

$n \le 10^6$

{% endnote %}
<!-- more -->

{% note success %}
可以转化为对线性同于方程判断是否有解的问题。

这里的线性同于方程组的模数 $\le 10^6$ 且不互质，$LCM$ 很大 无法 $exCRT$ 合并。

$O(n \operatorname{log} n)$：
从 $1 ~ n$ 枚举 $i$ 尝试求出 $x \operatorname{mod} i$ 的数值，易知 这个值可以从 $x \operatorname{mod} k \dot i$ 的值得到，检查方程组中所有的方程，看看是否冲突即可。根据调和级数，这样做的时间复杂度为 $O(n \operatorname{log} n)$。
{% endnote %}

```cpp
#define i64 long long 
#define walk(now, ex) for(int i = head[now], ex; ex = edge[i].node, i; i = edge[i].nxt)
bool vis[_];
vector<int> G[_];
int D[_], SZ[_], BL[_];
int Dis[_], MD[_];
int cnt = 0;
void clear(){
	memset(head, 0, sizeof(head)); tot = 0;
	memset(vis, false, sizeof(vis));
	for(int i = 1; i <= cnt; i++) G[i].clear(); cnt = 0;
}
void dfs(int now, int target){
	G[target].push_back(now);  vis[now] = 1;
	walk(now, ex) { if(vis[ex]) continue; dfs(ex, target); }
}
bool CMP(const pair<int, int > & A, const pair<int, int > & B) { return A.fi < B.fi; }
int pos[_];
bool PdExist(int *Md, int *a, int n) {
	static vector< pair<int, int > > M, M0; M.clear(); M0.clear();
	for(int i = 1; i <= n; i++) M.push_back(make_pair(Md[i], a[i]));
	sort(M.begin(), M.end(), CMP);
	for(int i = 0; i < M.size(); i++) {
		int L = i, R = i;
		while(R + 1 < M.size() && M[L].fi == M[R + 1].fi) R++;
		for(int j = L; j <= R; j++) if(M[j].se != M[L].se) return false;
		M0.push_back(M[L]);
		i = R;
	}
	memset(pos, -1, sizeof(pos));
	int MAX = 0; for(int i = 0; i < M0.size(); i++) MAX = max(MAX, M0[i].fi), pos[M0[i].fi] = i;
	for(int i = 1; i <= MAX; i++){
		int tmp = -1;
		for(int j = i; j <= MAX; j += i) if(pos[j] != -1) { if(tmp == -1) tmp = M0[pos[j]].se % i; else if(tmp != M0[pos[j]].se % i) return false; }
	}
	return true;
}

void doit(){
	clear();
	for(int i = 1; i <= n; i++) add(A[i], i);
	for(int i = 1; i <= n; i++) if(!vis[i]) dfs(i, ++cnt);
	for(int i = 1; i <= cnt; i++) {
		for(int j = 0; j < G[i].size(); j++){
			D[G[i][j]] = j;
			SZ[G[i][j]] = G[i].size();
			BL[G[i][j]] = i;	
		}
	}
	for(int i = 1; i <= n; i++) if(BL[A[i]] != BL[B[i]]) { return (void)puts("No");}
	for(int i = 1; i <= n; i++) Dis[i] = ( D[B[i]] - D[A[i]] + SZ[A[i]] ) % SZ[A[i]];
	
	for(int i = 1; i <= n; i++) MD[i] = SZ[A[i]];
	int r = PdExist(MD, Dis, n);
	return (void)puts(r ? "Yes" : "No"); 
}

int main(){
	while(scanf("%d", &n) == 1){
		for(int i = 1; i <= n; i++) Read(A[i]);
		for(int i = 1; i <= n; i++) Read(B[i]);
		doit();
	}
	return 0;
}
```

