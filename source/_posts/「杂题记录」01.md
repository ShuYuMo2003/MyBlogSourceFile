---
title: 「正睿OI」「国庆集训-重庆」01
date: 2020-11-18 11:41:50
tags:
 - 题解
 - 正睿
categories:
 - 杂题记录
---

[link](http://zhengruioi.com/contest/766/problem/394)
{% note info %}
给出一个长度为 $n$ 的 `01` 串 $s$ 和整数 $k$ ，求一个 $s$ 最长的子串 $t$ 使得 $t$ 中 `0` 的个数是 `1` 的个数的 $k$ 倍，输出最长的 $t$ 的长度。
{% endnote %}
<!-- more -->
{% note success %}
设$ S_0[i]$ 表示 $S[1..i]$中 `0`的数量。 $S_1[i]$ 表示 $S[1..i]$中 `1`的数量。
字串 $S[L, R]$ 满足条件当且仅当 $S_0[R] - S_0[L - 1] = (S_1[R] - S_1[L - 1]) \times k$。
即：$S_0[R] - S_1[R] \times k = S_0[L - 1] - S_1[L - 1] \times k$。
{% endnote %}
```cpp
#define i64 long long 
const int _ = 1e6 + 100;
int n, k;
char S[_];
int S0[_], S1[_];
map<long long, int >M;
int main(){ 
	ios::sync_with_stdio(false);
	cin >> n >> k >> (S + 1); 
	for(int i = 1; i <= n; i++) S0[i] = S0[i - 1] + (S[i] == '0'), S1[i] = S1[i - 1] + (S[i] == '1');
	int ans = 0;  
	M[0] = 0;
	for(int i = 1; i <= n; i++){
		i64 now = S0[i] -0ll- k *1ll* S1[i];
		if(M.count(now)) ans = max(ans, i - M[now]);  else M[now] = i;
	}
	printf("%d\n", ans); cerr << "std's ans = " << ans << endl;
	return 0;
}
```
