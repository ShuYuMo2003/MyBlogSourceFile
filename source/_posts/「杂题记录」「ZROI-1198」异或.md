---
title: 「杂题记录」「ZROI-1198」异或
mathjax: true
date: 2020-08-28 09:58:18
tags:
 - 构造
 - 异或
categories:
 - 杂题记录
---
## 题意
给树$T=(V, E)$上一些指定点赋值，使其满足下列要求
 - $$\left( \bigoplus\limits_{(u_i, v_i) \in \text{E}}u_i \oplus v_i \right) \oplus n = 0$$
 - $$\forall i,j \in \text{V}, V_i \neq V_j$$ 
 - $$\forall i \in \text{v}, V_i \leq 10^6 $$ 

输出任意一种合法地构造方案， 如果不存在 输出$-1$。

$n \leq 10^5$

<!-- more -->
## 分析

可以发现，一个点有贡献，当且仅当这个点的度数为奇数。

考虑对点分类，可以分成$4$类：
 - 可修改点：
   - 有贡献 (1)
   - 无贡献 (2)
 - 不可修改点：
   - 有贡献 (3)
   - 无贡献 (4)

可以修改的，有贡献的点顺序构造即可，根据异或的性质，前面的点可以任意填数，最后一个点考虑调整整个序列异或和为$0$即可。

考虑如何调整最后一个点。

如果最后一个点$i$调整之后和前面的某个已经填过的值相等，可以考虑将 $V_i$ 的最高位的下一位（第$k$位置）调整成$1$，然后再在前面找到任意一个已经填好的数字，将其第$k$位变成$1$即可。

根据异或的性质可以得知，同时修改两个数字的同一位置，异或和不变。

记录一下哪些数字被用到了，填数字的时候尽量填写小的数字。

{% note success %}
#### 判断无解
如果按上面的做法做了，最后任然没有找到合法的方案，就说明并没有合法的修改方案。

可以证明，这样判断无解的方法，可以判断出所有情况（允许修改的点权对答案没有贡献、没有给出可优化的点、给出的可调整的点无法调整为合法且不重复的值等等）。
{% endnote %}

{% note warning %}
#### 注意
 - 应该分情况考虑每一个结点的贡献、类型。
   简单题也需要注意细节`QAQ`
 - `while(k <= MAX) k <<= 1;` 注意这里是小于等于 而不是 小于。
{% endnote %}

## code
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
const int _ = 2e5 + 100;
const int MAXV = 2e6 + 1;
using namespace std;
int read(){ int x; scanf("%d", &x); return x; }
int ind[_], C[_];
int num[_];
int book[MAXV];
int MAX = 0;
int outs[_];
inline int type(int i) { return C[i] == 1 ? ((ind[i] & 1) == 1 ? 1 : 2) : ((ind[i] & 1) == 1 ? 3 : 4); }
int n;
int main(){
    freopen("in.txt", "r", stdin);
    n = read();
    for(int i = 1; i <= n; i++) C[i] = read();
    for(int i = 1; i < n; i++) ind[read()]++, ind[read()] ++;
    int all = n;
    int tot = 0;
    for(int i = 1; i <= n; i++){
        if(type(i) == 1) tot++;
        if(type(i) == 3) all ^= i;
        if(type(i) == 3 || type(i) == 4) book[i] = 1, MAX = max(MAX, i);
    }
    int k = 1;
    for(int i = 1; i < tot; i++){
        while(book[k]) k++; book[k] = 1;
        num[i] = k; all ^= k; MAX = max(MAX, k);
    }
    num[tot] = all;
    MAX = max(MAX, all);
    if(book[all] || all == 0){
        int k = 1;
        while(k <= MAX) k <<= 1;
        num[tot] ^= k; book[num[tot]] = 1;
        book[num[1]] = 0;
        num[1]   ^= k;
        book[num[1]] = 1;
    } else book[all] = 1, num[tot] = all;
    
    int res = 0;
    k = 1;
    for(int i = 1; i <= n; i++) {
        if(type(i) == 1) outs[i] = num[++res];
        if(type(i) == 2) { while(book[k]) k++; outs[i] = k; book[k] = 1; }
        if(type(i) == 3 || type(i) == 4) { outs[i] = i; }
    }
    int chk = n;
    for(int i = 1; i <= n; i++) if(type(i) == 1 || type(i) == 3) chk ^= outs[i];
    if(chk != 0) { puts("No"); return 0; }
    for(int i = 1; i <= n; i++) if(outs[i] > 1e6 || outs[i] < 1) { puts("No"); return 0; }
    memset(book, 0, sizeof(book));
    for(int i = 1; i <= n; i++) if(book[outs[i]]) { puts("No"); return 0; } else { book[outs[i]] = 1; }
    puts("Yes");
    for(int i = 1; i <= n; i++) printf("%d ", outs[i]);
    return 0;
}
```


