---
title: 「正睿OI」「国庆集训-重庆」排列
mathjax: true
date: 2020-11-18 11:42:24
tags:
 - 题解
 - 正睿
 - dp
categories:
 - 杂题记录
---

{% note info %}
有两个长度为 $n$ 的排列 $A,B$ ，你每次可以进行三种操作：
 - 删除 $A$ 的第一个元素 $a$
 - 删除 $B$ 的第一个元素 $b$
 - 删除 $A$ 的第一个元素 $a$ 和 $B$ 的第一个元素 $b$ ，要求 $a\neq b$
求把 $A,B$ 都删光需要的最少操作次数。

$n \le 10^6$

{% endnote %}
<!-- more -->
{% note success %}
当数列 $A, B$ 的首项相同的时候，直接贪心的选择操作 3 。需要决策当 $A, B$ 首项相同的时候选择删除那边的，然后又可以一直删，直到首项再次相同的时候 再决策，直接DP可能被**卡住**的地方即可。

设数字 $x$ 在 $A$ 中的位置是 $i$，在 $B$ 中的位置是 $j$，记 数字 $x$ 的位置为二元组 $(i, j)$。由于 $A , B$ 是两个排列，对于数字 $x$ ，其位置一定是唯一的 $(i, j)$。
设 $\operatorname{dp}[i]$ 为 (设 $A_i$ 的位置为 $(i, j)$ ) ，删光 $A[i..n]$ 和 $B[j..n]$ 的代价。

对于数值 $x$ 的位置 $(i, j)$ 设 $\Delta = i - j $。由于排列的性质，$dp[i]$、$A_i$ 的位置 $(i, j)$这些是一一对应的。设 $\Delta(x)$ 为 $dp[x]$ 对应的 $\Delta$。

转移就是 

$dp[i] = 1 + \min_{\Delta(x) = \Delta(i) - 1, \Delta(y) = \Delta(i) + 1}\limits{\{\ dp[x] + \operatorname{dist}(i, x),\ \ dp[y] + \operatorname{dist}(i, y)}\ \}$。

从后往前 $dp$ 记录以下 $\Delta$ 即可。
为了方便，其中 $\operatorname{Last}$ 为 $\Delta()$ 的反函数。
{% endnote %}
```cpp
int n, A[_], B[_], POOL[(_ << 1) + 100], PosInB[_], *Last = &POOL[_ + 10];
int dp[_];
int main(){
    rep(i, 1, n = read()) Read(A[i]); rep(i, 1, n) Read(B[i]), PosInB[B[i]] = i;
    clear(dp, 0x3f); clear(POOL, -1);
    per(i, 1, n) {
        int det = i - PosInB[A[i]];
        if(Last[det + 1] != -1) to_min(dp[i], dp[Last[det + 1]] + 1 + (Last[det + 1] - (i + 1)));
        else to_min(dp[i], 1 + max(n - (i + 1) + 1, n - (PosInB[A[i]]) + 1 ));
        if(Last[det - 1] != -1) to_min(dp[i], dp[Last[det - 1]] + 1 + (Last[det - 1] - (i)));
        else to_min(dp[i], 1 + max(n - (i) + 1, n - (PosInB[A[i]] + 1) + 1));
        Last[det] = i;
    }
    int ans = 0;
    if(Last[0] == -1) ans = n; else ans = dp[Last[0]] + Last[0] - 1;
    printf("%d", ans);
    return 0;
}
```
